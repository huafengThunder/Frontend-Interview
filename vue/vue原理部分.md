#### 第三方组件样式不生效,解决方式有哪些；采用的什么原理
  - 解决:
    - 1,穿透scoped限制,使用深度选择器(>>> v-::deep)
    - 2,去掉scoped限制,通过父组件加上选择器限制
  - 原理:
    - 类似postcss,给class加上属性限制

- 虚拟dom,说说key的作用,说说diff算法流程
  - key的作用
    - 假若没有key的话,节点没有修改操作(无状态组件),可以不用使用key,节点会直接复用;省去了组件创建/销毁的开销。
    - 使用加上key的就是给VNode加上id,只用key相同就表示节点相同;
      - 新的虚拟节点有没变化,直接复用之前的
      - 新的虚拟节点有变化,则生成新的dom,并替换页面中的dom
      - 旧虚拟DOM中未找到与新虚拟DOM相同的key,创建新的真实DOM，随后渲染到到页面
  - diff流程
    - 同级节点直接比较,逐级替换,一个循环遍历完成;
      - 同级节点直接比较是分有key和无key的情况
#### vue响应式原理

#### computed和watch原理,分别发生在哪个生命周期

#### Vue.$nextTick为什么比setTimeout优先级高,渲染也更快生效

#### Vue的虚拟节点更新是同步还是一部
- 数据是同步更新，视图是异步更新
- 导致多次渲染浪费不必要的性能，没必要，内部做了去重(重新更新的值)和防抖(只更新最后一次)
#### template到真实dom的过程
- 获取html
- 转化ast
- generate函数生成rander函数
- rander函数生成虚拟dom
- 生成真实dom
#### new Vue发生了什么


